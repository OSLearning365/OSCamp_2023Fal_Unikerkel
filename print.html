<!DOCTYPE HTML>
<html lang="cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>unikernel practical tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch1.html"><strong aria-hidden="true">1.</strong> 第一周</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1-1.html"><strong aria-hidden="true">1.1.</strong> 练习1：支持彩色打印println!</a></li><li class="chapter-item expanded "><a href="ch1-2.html"><strong aria-hidden="true">1.2.</strong> 练习2：支持HashMap数据类型</a></li><li class="chapter-item expanded "><a href="ch1-3.html"><strong aria-hidden="true">1.3.</strong> 练习3：为内存分配器实现新的内存算法</a></li><li class="chapter-item expanded "><a href="ch1-4.html"><strong aria-hidden="true">1.4.</strong> 练习4：解析dtb并打印</a></li><li class="chapter-item expanded "><a href="ch1-5.html"><strong aria-hidden="true">1.5.</strong> 练习5：抢占式调度算法</a></li></ol></li><li class="chapter-item expanded "><a href="ch2.html"><strong aria-hidden="true">2.</strong> 第二周</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch9-1.html"><strong aria-hidden="true">2.1.</strong> FAQ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">unikernel practical tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/unikernel-practical-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="第一周"><a class="header" href="#第一周">第一周</a></h2>
<p>本实验指导是为 2024 春夏季 OS 训练营第三阶段 - 项目1：ArceOS 单内核 Unikernel 方向，而做的前期准备。这是第一周的练习内容，包含 5 个基本练习。</p>
<p>对完练习的过程要求：</p>
<ol>
<li>按照下节 <em><strong>环境准备</strong></em> 要求建立分支。</li>
<li>成功的截图发到群里。</li>
<li>仓库链接发邮件到 sun_ye@massclouds.com。</li>
</ol>
<h3 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h3>
<ol>
<li>
<p>Fork ArceOS的工程，clone到本地。工程链接如下：</p>
<pre><code class="language-sh">git@github.com:arceos-org/arceos.git
</code></pre>
</li>
<li>
<p>在main分支下，创建并切换到新的分支week1，执行：</p>
<pre><code class="language-shell">git checkout -b week1
</code></pre>
<p>第一周的练习都在该分支下进行。</p>
</li>
</ol>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="练习1支持彩色打印-println"><a class="header" href="#练习1支持彩色打印-println">练习1：支持彩色打印 println!</a></h2>
<p><strong>目标：</strong></p>
<p>支持彩色打印 println!。以 apps/helloworld 为测试应用。</p>
<p><strong>要求</strong>：</p>
<p>不能在 helloworld 程序本身改，要在下面的库或更深层次的组件修改。</p>
<p><strong>预期输出</strong>：</p>
<p>执行<code>make run ARCH=riscv64</code>，输出的效果：</p>
<div style="text-align:center">
   <img src=".\img\1-1.png" alt="1-1" style="zoom:80%"/>
</div>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="练习2支持hashmap数据类型"><a class="header" href="#练习2支持hashmap数据类型">练习2：支持HashMap数据类型</a></h2>
<p><strong>目标：</strong></p>
<p>支持 HashMap 数据类型。以 apps/memtest 为测试应用。</p>
<p>首先修改 apps/memtest/src/main.rs，把 BTreeMap 替换为 HashMap，如下：</p>
<pre><code class="language-diff"> use rand::{rngs::SmallRng, RngCore, SeedableRng};
-use std::collections::BTreeMap;
+use std::collections::HashMap;
 use std::vec::Vec;

 fn test_vec(rng: &amp;mut impl RngCore) {
@@ -22,9 +22,9 @@ fn test_vec(rng: &amp;mut impl RngCore) {
     println!("test_vec() OK!");
 }

-fn test_btree_map(rng: &amp;mut impl RngCore) {
+fn test_hashmap_map(rng: &amp;mut impl RngCore) {
     const N: usize = 50_000;
-    let mut m = BTreeMap::new();
+    let mut m = HashMap::new();
     for _ in 0..N {
         let value = rng.next_u32();
         let key = format!("key_{value}");
@@ -35,7 +35,7 @@ fn test_btree_map(rng: &amp;mut impl RngCore) {
             assert_eq!(k.parse::&lt;u32&gt;().unwrap(), *v);
         }
     }
-    println!("test_btree_map() OK!");
+    println!("test_hashmap_map() OK!");
 }

 #[cfg_attr(feature = "axstd", no_mangle)]
@@ -44,7 +44,7 @@ fn main() {

     let mut rng = SmallRng::seed_from_u64(0xdead_beef);
     test_vec(&amp;mut rng);
-    test_btree_map(&amp;mut rng);
+    test_hashmap_map(&amp;mut rng);

     println!("Memory tests run OK!");
 }
</code></pre>
<p>然后，尝试编译运行，<code>make A=apps/memtest ARCH=riscv64 run</code>，此时会报错，因为我们目前不支持HashMap 类型。</p>
<p><strong>要求</strong>：</p>
<p>在 ulib/axstd 中支持 HashMap 类型</p>
<p><strong>预期输出</strong>：</p>
<p>执行 <code>make A=apps/memtest ARCH=riscv64 run</code></p>
<pre><code class="language-sh">arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
smp = 1
build_mode = release
log_level = warn

Running memory tests...
test_vec() OK!
test_hashmap_map() OK!
Memory tests run OK!
</code></pre>
<p><strong>提示</strong> ：</p>
<ol>
<li>
<p>参考官方 rust 标准库中的 HashMap 实现，把涉及的代码拷过来，做一下修改。只需要满足 memtest 的测试需要即可。</p>
</li>
<li>
<p>注意：官方 std 与 ArceOS 的 axstd 的区别。官方 rust 标准库主要是基于 Linux/Windows 这些内核，为应用提供的用户库。官方 std 的支持后端是 libc+syscall；而 ArceOS 是单特权级，没有 syscall 一说，axstd 直接通过一系列 function-call 调用底层的功能。</p>
</li>
<li>
<p>HashMap 之所以没有像其他 collections 类型一样放到 alloc 库中实现，主要是因为它需要随机数的支持，而随机数的产生机制是平台相关的。大家做实验可以简单点，用一个软实现的随机数函数来产生。比如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use spinlock::SpinNoIrq;
use crate::time;

static PARK_MILLER_LEHMER_SEED: SpinNoIrq&lt;u32&gt; = SpinNoIrq::new(0);
const RAND_MAX: u64 = 2_147_483_647;

pub fn random() -&gt; u128 {
    let mut seed = PARK_MILLER_LEHMER_SEED.lock();
    if *seed == 0 {
        *seed = time::current_ticks() as u32;
    }

    let mut ret: u128 = 0;
    for _ in 0..4 {
        *seed = ((u64::from(*seed) * 48271) % RAND_MAX) as u32;
        ret = (ret &lt;&lt; 32) | (*seed as u128);
    }
    ret
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="练习3为内存分配器实现新的内存算法"><a class="header" href="#练习3为内存分配器实现新的内存算法">练习3：为内存分配器实现新的内存算法</a></h2>
<p><strong>目标：</strong></p>
<p>为内存分配器实现新的内存算法 early，禁用其它算法。early 分配算法以 apps/memtest 为测试应用。</p>
<p><strong>首先</strong>，为 memtest 增加 feature = "paging"，便于查看对 Page 的分配情况。修改 apps/memtest/Cargo.toml，对比变动如下</p>
<pre><code class="language-toml">-axstd = { path = "../../ulib/axstd", features = ["alloc"], optional = true }
+axstd = { path = "../../ulib/axstd", features = ["alloc", "paging"], optional = true }
</code></pre>
<p><strong>然后</strong>，修改 modules/axruntime/src/lib.rs 增加下面几行，对比变动：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>+    {
+        let ga = axalloc::global_allocator();
+        info!("Used pages {} / Used bytes {}", ga.used_pages(), ga.used_bytes());
+    }
     unsafe { main() };
<span class="boring">}</span></code></pre></pre>
<p>这几行的目的，在调用应用的 main() 之前，输出对页和字节的用量。</p>
<p><strong>最后</strong>，用下面的内容替换 modules/axalloc/src/lib.rs，禁用其它算法，只使用我们将要增加的 early 算法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[macro_use]
extern crate log;
extern crate alloc;

mod page;

use allocator::{AllocResult, EarlyAllocator};
use core::alloc::{GlobalAlloc, Layout};
use core::ptr::NonNull;
use spinlock::SpinNoIrq;

const PAGE_SIZE: usize = 0x1000;

pub use page::GlobalPage;

/// The global allocator used by ArceOS.
pub struct GlobalAllocator {
    inner: SpinNoIrq&lt;EarlyAllocator&lt;PAGE_SIZE&gt;&gt;,
}

impl GlobalAllocator {
    /// Creates an empty [`GlobalAllocator`].
    pub const fn new() -&gt; Self {
        Self {
            inner: SpinNoIrq::new(EarlyAllocator::new()),
        }
    }

    /// Returns the name of the allocator.
    pub const fn name(&amp;self) -&gt; &amp;'static str {
        "early"
    }

    /// Initializes the allocator with the given region.
    pub fn init(&amp;self, start_vaddr: usize, size: usize) {
        self.inner.lock().init(start_vaddr, size);
    }

    /// Add the given region to the allocator.
    pub fn add_memory(&amp;self, _start_vaddr: usize, _size: usize) -&gt; AllocResult {
        unimplemented!()
    }

    /// Allocate arbitrary number of bytes. Returns the left bound of the
    /// allocated region.
    pub fn alloc(&amp;self, layout: Layout) -&gt; AllocResult&lt;NonNull&lt;u8&gt;&gt; {
        self.inner.lock().alloc(layout)
    }

    /// Gives back the allocated region to the byte allocator.
    pub fn dealloc(&amp;self, pos: NonNull&lt;u8&gt;, layout: Layout) {
        self.inner.lock().dealloc(pos, layout)
    }

    /// Allocates contiguous pages.
    pub fn alloc_pages(&amp;self, num_pages: usize, align_pow2: usize) -&gt; AllocResult&lt;usize&gt; {
        self.inner.lock().alloc_pages(num_pages, align_pow2)
    }

    /// Gives back the allocated pages starts from `pos` to the page allocator.
    /// [`alloc_pages`]: GlobalAllocator::alloc_pages
    pub fn dealloc_pages(&amp;self, pos: usize, num_pages: usize) {
        self.inner.lock().dealloc_pages(pos, num_pages)
    }

    /// Returns the number of allocated bytes in the byte allocator.
    pub fn used_bytes(&amp;self) -&gt; usize {
        self.inner.lock().used_bytes()
    }

    /// Returns the number of available bytes in the byte allocator.
    pub fn available_bytes(&amp;self) -&gt; usize {
        self.inner.lock().available_bytes()
    }

    /// Returns the number of allocated pages in the page allocator.
    pub fn used_pages(&amp;self) -&gt; usize {
        self.inner.lock().used_pages()
    }

    /// Returns the number of available pages in the page allocator.
    pub fn available_pages(&amp;self) -&gt; usize {
        self.inner.lock().available_pages()
    }
}

unsafe impl GlobalAlloc for GlobalAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        if let Ok(ptr) = GlobalAllocator::alloc(self, layout) {
            ptr.as_ptr()
        } else {
            alloc::alloc::handle_alloc_error(layout)
        }
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        GlobalAllocator::dealloc(self, NonNull::new(ptr).expect("dealloc null ptr"), layout)
    }
}

#[cfg_attr(all(target_os = "none", not(test)), global_allocator)]
static GLOBAL_ALLOCATOR: GlobalAllocator = GlobalAllocator::new();

/// Returns the reference to the global allocator.
pub fn global_allocator() -&gt; &amp;'static GlobalAllocator {
    &amp;GLOBAL_ALLOCATOR
}

/// Initializes the global allocator with the given memory region.
pub fn global_init(start_vaddr: usize, size: usize) {
    debug!(
        "initialize global allocator at: [{:#x}, {:#x})",
        start_vaddr,
        start_vaddr + size
    );
    GLOBAL_ALLOCATOR.init(start_vaddr, size);
}

/// Add the given memory region to the global allocator.
pub fn global_add_memory(_start_vaddr: usize, _size: usize) -&gt; AllocResult {
    unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<p>上面已经给出了 axalloc 组件的主框架和对 crates/allocator/early 算法组件的调用，同时去除了其它算法，方便大家实验。</p>
<p>现在，如果执行 <code>make ARCH=riscv64 A=apps/memtest LOG=debug run</code>，当然会出错。</p>
<p><strong>要求</strong>：</p>
<p>从前往后字节分配，从后往前页分配。</p>
<p><strong>提示</strong>：</p>
<ol>
<li>
<p>modules/axalloc 组件要去调用实现在 crates/allocator 中的算法。现在其它算法都无效了，我们只要在crates/allocator/src/lib.rs 中增加如下几行，引入 early 模块，代表算法的类型为 EarlyAllocator。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod early;
pub use early::EarlyAllocator;
<span class="boring">}</span></code></pre></pre>
<p>新建 crates/allocator/src/early.rs，后面主要的逻辑实现都在这个模块中。</p>
</li>
<li>
<p>可以参考禁用掉的 buddy/slab 等字节分配算法、bitmap 页分配算法，来实现 early 算法。正常来说，EarlyAllocator 需要实现像 BaseAllocator、ByteAllocator、PageAllocator 这三个 trait 来为 axalloc 提供调用服务，但为了实验方便，也可以不实现，直接为 EarlyAllocator 关联对应的方法即可。</p>
</li>
<li>
<p>early算法图示如下，供参考：</p>
<div style="text-align:center">
   <img src=".\img\1-2-0.svg" alt="1-2-0" style="zoom:50%"/>
</div>
</li>
</ol>
<p><strong>预期输出</strong>：</p>
<p>执行 <code>make ARCH=riscv64 A=apps/memtest LOG=debug run</code>，输出</p>
<div style="text-align:center">
   <img src=".\img\1-2.png" alt="1-2" style="zoom:100%"/>
</div>
<p>注意：这个已分配的页面数正常就是 6，而显示的字节数可能与你执行时的情况不同，但不会是 0。</p>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="练习4解析dtb并打印"><a class="header" href="#练习4解析dtb并打印">练习4：解析dtb并打印</a></h2>
<p><strong>目标：</strong></p>
<p>解析 dtb（FDT 的二进制格式），打印物理内存范围和所有的 virtio_mmio 范围。以 apps/memtest 为测试应用。</p>
<p>当 ArceOS 启动时，上一级 SBI 向我们传递了 dtb 的指针，一直会被传递到 axruntime，我们就在 axruntime 中执行解析并打印。</p>
<p>首先，在 /modules/axruntime/src/lib.rs 的 rust_main 函数中，插入如下代码以显示获取到的信息，diff 内容如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>--- a/modules/axruntime/src/lib.rs
+++ b/modules/axruntime/src/lib.rs
@@ -140,6 +140,20 @@ pub extern "C" fn rust_main(cpu_id: usize, dtb: usize) -&gt; ! {
     #[cfg(feature = "alloc")]
     init_allocator();

+    // Parse fdt for early memory info
+    let dtb_info = match parse_dtb(dtb.into()) {
+        Ok(info) =&gt; info,
+        Err(err) =&gt; panic!("Bad dtb {:?}", err),
+    };
+
+    info!("DTB info: ==================================");
+    info!("Memory: {:#x}, size: {:#x}", dtb_info.memory_addr, dtb_info.memory_size);
+    info!("Virtio_mmio[{}]:", dtb_info.mmio_regions.len());
+    for r in dtb_info.mmio_regions {
+        info!("\t{:#x}, size: {:#x}", r.0, r.1);
+    }
+    info!("============================================");
+
     #[cfg(feature = "paging")]
     {
         info!("Initialize kernel page table...");
@@ -297,3 +311,74 @@ fn init_tls() {
     unsafe { axhal::arch::write_thread_pointer(main_tls.tls_ptr() as usize) };
     core::mem::forget(main_tls);
 }
<span class="boring">}</span></code></pre></pre>
<p>关于 parse_dtb 和它的返回值类型，类似如下定义，你对它们的具体定义有所可以不同：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate alloc;

use core::str;
use alloc::string::String;
use alloc::vec::Vec;
use axdtb::util::SliceRead;

// 参考类型定义
struct DtbInfo {
    memory_addr: usize,
    memory_size: usize,
    mmio_regions: Vec&lt;(usize, usize)&gt;,
}

// 参考函数原型
fn parse_dtb(dtb_pa: usize) -&gt; Result&lt;DtbInfo&gt; {
    // 这里就是对axdtb组件的调用，传入dtb指针，解析后输出结果。这个函数和axdtb留给大家实现
}
<span class="boring">}</span></code></pre></pre>
<p>然后就是本实验的中心任务：modules 目录中增加一个 axdtb 的组件，它负责解析 dtb，获取目标信息。</p>
<p><strong>提示</strong>：</p>
<p>解析 dtb（FDT 的二进制格式）有点繁琐，但是网络上存在很多现成的 crate 实现，例如 crate.io 中。</p>
<p>但是注意：有可能这些 crate 不直接符合我们的需要，需要改造。主要是很多实现都是以文件路径为输入，加载文件到内存后，再解析。我们只需要进行解析的那部分。</p>
<p><strong>预期输出</strong>：</p>
<p>执行 <code>make ARCH=riscv64 A=apps/memtest LOG=info run</code></p>
<div style="text-align:center">
   <img src=".\img\1-3.png" alt="1-3" style="zoom:80%"/>
</div>
可以看到输出了解析 dtb 后的物理内存信息，和 virtio_mmio 区域信息。
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="练习5抢占式调度算法"><a class="header" href="#练习5抢占式调度算法">练习5：抢占式调度算法</a></h2>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<p>把协作式调度算法 fifo 改造为抢占式调度算法。让测试应用通过。</p>
<h3 id="准备"><a class="header" href="#准备">准备</a></h3>
<p><strong>首先</strong>，在 apps 下面增加一个测试应用 ex5，它的 main.rs 如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![cfg_attr(feature = "axstd", no_std)]
#![cfg_attr(feature = "axstd", no_main)]

#[macro_use]
#[cfg(feature = "axstd")]
extern crate axstd as std;

use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

static FLAG: AtomicUsize = AtomicUsize::new(0);

#[cfg_attr(feature = "axstd", no_mangle)]
fn main() {
    thread::spawn(move || {
        println!("Spawned-thread is waiting ...");
        while FLAG.load(Ordering::Relaxed) &lt; 1 {
            // For cooperative scheduler, we must yield here!
            // For preemptive scheduler, just relaxed! Leave it for scheduler.
        }

        let _ = FLAG.fetch_add(1, Ordering::Relaxed);
    });

    // Give spawned thread a chance to start.
    thread::yield_now();

    println!("Main thread set FLAG to notify spawned-thread to continue.");
    let _ = FLAG.fetch_add(1, Ordering::Relaxed);
    println!("Main thread waits spawned-thread to respond ...");
    while FLAG.load(Ordering::Relaxed) &lt; 2 {
        thread::yield_now();
    }
    println!("Preempt test run OK!");
}</code></pre></pre>
<p>ex5 的 Cargo.toml 的内容如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = "ex5"
version = "0.1.0"
edition = "2021"

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
axstd = { path = "../../ulib/axstd", features = ["alloc", "multitask", "irq"], optional = true }
<span class="boring">}</span></code></pre></pre>
<p>另外需要把 "apps/ex5" 加到<strong>工程根目录</strong> Cargo.toml 的 [workspace] 下的 members 中。</p>
<p><strong>然后</strong>，尝试运行一下，<code>make ARCH=riscv64 A=apps/ex5 run</code></p>
<div style="text-align:center">
   <img src=".\img\1-4.png" alt="1-4" style="zoom:100%"/>
</div>
<p>这样<strong>会卡住!!!</strong></p>
<p>原因就是默认调度策略 fifo 是协作式，大家可以参照 ex5 的应用逻辑想想。</p>
<p>如果希望运行下去，有两个办法：</p>
<p>一是加上 yield_now，如下</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        while FLAG.load(Ordering::Relaxed) &lt; 1 {
            // For cooperative scheduler, we must yield here!
            // For preemptive scheduler, just relaxed! Leave it for scheduler.
            // 在这里加 thread::yield_now();
        }
<span class="boring">}</span></code></pre></pre>
<p>大家可以试试！</p>
<p>二就是修改调度算法，也就是本练习的题目。<strong>注意</strong>：如果刚刚加上 yield_now 做实验了，现在别忘了删除这行:)</p>
<h3 id="题目"><a class="header" href="#题目">题目</a></h3>
<p><strong>要求</strong>：</p>
<p>直接修改 crates/scheduler/src/fifo.rs，让 ex5 通过。</p>
<p><strong>提示</strong>：</p>
<ol>
<li>可以比照 crates/scheduler/src/round_robin.rs 的实现进行修改。（请务必要做一遍!!!）</li>
<li>虽然本题目简单，但是如何为修改后的 fifo 调度算法启用 feature "preempt"，可能有点小麻烦，看看 rr/cfs是怎么传递的。</li>
</ol>
<p><strong>预期</strong>：</p>
<p>运行<code>make ARCH=riscv64 A=apps/ex5 run</code></p>
<div style="text-align:center">
   <img src=".\img\1-5.png" alt="1-5" style="zoom:100%"/>
</div>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="第二周"><a class="header" href="#第二周">第二周</a></h2>
<p>本实验指导是为 2024 春夏季 OS 训练营第三阶段 - 项目1：ArceOS 单内核 Unikernel 方向，而做的前期准备。这是第二周的练习内容，目标是在 ArceOS Unikernel OS 模式下，完成几个基本实验与附加练习，为支持多应用的实习任务做准备。</p>
<ol>
<li>基本实验：本指导书以增量的方式基本给出了 1 到 5 共 5 个实验的源码及过程，大家照着做一遍，以熟悉基本原理机制。</li>
<li>附加练习：基于基本实验，根据自己的理解，增加一些实现，以达到练习要求目标。总共 6 个练习。</li>
</ol>
<p>对完成实验和练习的过程要求：</p>
<ol>
<li>按照下节 <em><strong>环境准备</strong></em> 第 2 点要求分别建立分支，并 commit。</li>
<li>成功的截图发到群里。</li>
<li>仓库链接发邮件到 sun_ye@massclouds.com。<strong>注意</strong>：第一周发过邮件的同学，只要你的仓库未改，<strong>不用</strong>发邮件。我们保留了你们的仓库，可以直接去对应分支上查看各位的代码。所以请务必按照后面的要求建立分支和标记 commit 消息。</li>
</ol>
<h3 id="环境准备-1"><a class="header" href="#环境准备-1">环境准备</a></h3>
<ol>
<li>
<p>Fork ArceOS 的工程，clone 到本地。工程链接如下：</p>
<pre><code class="language-bash">git@github.com:arceos-org/arceos.git
</code></pre>
<p>通过 <code>git log</code> 查看 commit id 是否为 <em>51a42ea4d65a53bf6b43fc35a27a3ff1e9e284c7</em>。如果不是，回退到这个 commit，确保工作的基线与指导书一致。</p>
<blockquote>
<p><font size=2>注意：进行过项目 1 第一周练习的同学，这步应该已经具备，直接从第 2 步开始。</font></p>
</blockquote>
</li>
<li>
<p>建立并切换到分支 week2_base：</p>
<pre><code class="language-bash">git checkout main
git checkout -b week2_base
</code></pre>
<p>这个分支对应<strong>基本实验</strong>。开始实验时，每完成一个，就 commit  一次，commit msg 是 "step N"，N 是实验序号。</p>
</li>
<li>
<p>建立并切换到分支 week2_exercise：</p>
<pre><code class="language-bash">git checkout main
git checkout -b week2_exercise
</code></pre>
<p>这个分支对应<strong>附加练习</strong>。根据每个附加练习的要求完成，每完成一个，commit 一次，commit msg 是 "exercise N"，N 是练习序号。</p>
</li>
<li>
<p>执行 <code>make run ARCH=riscv64</code> 测试一下环境，我们的实习平台是 <strong>riscv64-qemu-virt</strong>。</p>
<pre><code class="language-bash">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
smp = 1
build_mode = release
log_level = warn

Hello, world!
</code></pre>
<p>看到这个输出表示环境正常。</p>
</li>
</ol>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h4 id="问题1"><a class="header" href="#问题1">问题1</a></h4>
<p>运行ArceOS时，提示：Unable to load the RISC-V firmware"opensbi-riscv64-generic-fw_dynamic.bin'</p>
<h5 id="解决思路"><a class="header" href="#解决思路"><strong>解决思路：</strong></a></h5>
<p>Qemu版本过低，需求使用Qemu8或更高版本。</p>
<p>说明：各个发行版Qemu有差别。如果是Unbuntu22.04，直接apt install安装就可以。如果自己编译，使用Qemu官网最新版本。</p>
<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
